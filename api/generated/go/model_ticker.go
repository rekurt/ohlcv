/*
 * PointPay.io Public Spot API (draft)
 *
 * OpenAPI Specifications for the PointPay.io Public Spot API
 *
 * API version: 0.1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

type Ticker struct {
	Symbol string `json:"symbol"`

	PriceChange string `json:"priceChange"`

	PriceChangePercent string `json:"priceChangePercent"`

	PrevClosePrice string `json:"prevClosePrice"`

	LastPrice string `json:"lastPrice"`

	BidPrice string `json:"bidPrice"`

	BidQty string `json:"bidQty"`

	AskPrice string `json:"askPrice"`

	AskQty string `json:"askQty"`

	OpenPrice string `json:"openPrice"`

	HighPrice string `json:"highPrice"`

	LowPrice string `json:"lowPrice"`

	Volume string `json:"volume"`

	QuoteVolume string `json:"quoteVolume"`

	OpenTime int64 `json:"openTime"`

	CloseTime int64 `json:"closeTime"`

	FirstId string `json:"firstId"`

	LastId string `json:"lastId"`

	Count int64 `json:"count"`
}

// AssertTickerRequired checks if the required fields are not zero-ed
func AssertTickerRequired(obj Ticker) error {
	elements := map[string]interface{}{
		"symbol":             obj.Symbol,
		"priceChange":        obj.PriceChange,
		"priceChangePercent": obj.PriceChangePercent,
		"prevClosePrice":     obj.PrevClosePrice,
		"lastPrice":          obj.LastPrice,
		"bidPrice":           obj.BidPrice,
		"bidQty":             obj.BidQty,
		"askPrice":           obj.AskPrice,
		"askQty":             obj.AskQty,
		"openPrice":          obj.OpenPrice,
		"highPrice":          obj.HighPrice,
		"lowPrice":           obj.LowPrice,
		"volume":             obj.Volume,
		"quoteVolume":        obj.QuoteVolume,
		"openTime":           obj.OpenTime,
		"closeTime":          obj.CloseTime,
		"firstId":            obj.FirstId,
		"lastId":             obj.LastId,
		"count":              obj.Count,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	return nil
}

// AssertRecurseTickerRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Ticker (e.g. [][]Ticker), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseTickerRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aTicker, ok := obj.(Ticker)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertTickerRequired(aTicker)
	})
}
